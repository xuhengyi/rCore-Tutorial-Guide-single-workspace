# 引言

## 本章导读

本章中内核将实现虚拟内存机制，这注定是一趟艰难的旅程。

通过虚拟内存机制，我们可以：
- 为每个应用程序提供独立的地址空间，实现隔离
- 通过页表机制进行地址转换，提供内存保护
- 支持更灵活的内存管理

## 实践体验

本章应用运行起来效果与上一章基本一致，但底层实现已经完全不同。

在 qemu 模拟器上运行本章代码：

```bash
$ cd ch4
$ cargo run
```

## 本章代码树

```
rCore-Tutorial-in-single-workspace/
├── ch4/
│   ├── Cargo.toml          # 项目配置文件
│   ├── build.rs            # 构建脚本
│   ├── README.md           # 本章说明文档
│   └── src/
│       ├── main.rs         # 内核主函数
│       └── process.rs      # 进程管理
├── kernel-vm/              # 虚拟内存管理库
│   └── src/
│       └── lib.rs          # 地址空间和页表管理
├── kernel-context/         # 内核上下文管理库（新增 foreign 功能）
│   └── src/
│       └── foreign/        # 跨地址空间的上下文切换
├── kernel-alloc/           # 内核堆分配器
│   └── src/
│       └── lib.rs          # 动态内存分配
├── linker/                 # 链接脚本和应用程序管理库
├── syscall/                # 系统调用库
├── console/                # 控制台库
└── sbi/                    # SBI 调用封装
```

本章代码相比第三章的主要变化：

- **虚拟内存管理**：使用 `kernel-vm` 库实现 SV39 分页机制
- **地址空间隔离**：内核和应用程序拥有独立的地址空间
- **跨地址空间访问**：通过 `ForeignContext` 实现跨地址空间的上下文切换
- **ELF 解析**：直接使用 ELF 格式文件，解析程序段信息
- **动态内存分配**：内核支持堆分配，可以使用 `Vec`、`Box` 等数据结构

## 关键概念

- **虚拟地址空间**：每个进程拥有独立的虚拟地址空间
- **页表**：用于虚拟地址到物理地址的转换
- **SV39 分页模式**：RISC-V 64 位架构的 39 位虚拟地址分页模式
- **地址空间隔离**：内核和应用程序的地址空间完全隔离
- **跨地址空间访问**：内核需要手动查页表来访问应用程序的数据
