# 第四章：地址空间

## 目录

1. [引言](0intro.md) - 本章导读和实践体验
2. [实现 SV39 多级页表机制（上）](3sv39-implementation-1.md) - 虚拟地址和页表项
3. [实现 SV39 多级页表机制（下）](4sv39-implementation-2.md) - 物理页帧管理和多级页表
4. [内核与应用的地址空间](5kernel-app-spaces.md) - 地址空间的创建和管理
5. [基于地址空间的分时多任务](6multitasking-based-on-as.md) - 跨地址空间的上下文切换
6. [练习](7exercise.md) - 编程作业和问答作业

## 本章目标

本章的目标是实现虚拟内存机制，为每个应用程序提供独立的地址空间，实现内存隔离和保护。

## 主要内容

1. **SV39 分页机制**：实现 RISC-V 64 位架构的 39 位虚拟地址分页模式
2. **地址空间抽象**：通过 `AddressSpace` 管理虚拟地址空间
3. **内核地址空间**：为内核创建独立的地址空间
4. **应用地址空间**：通过解析 ELF 文件为应用程序创建地址空间
5. **跨地址空间切换**：实现 Trap 和任务切换时的地址空间切换

## 代码位置

本章的代码位于 `rCore-Tutorial-in-single-workspace/ch4/` 目录下。

主要文件：
- `src/main.rs` - 内核主函数，包含地址空间创建和进程调度
- `src/process.rs` - 进程管理，包含 ELF 解析和进程创建

主要依赖库：
- `kernel-vm` - 虚拟内存管理库（`AddressSpace`）
- `kernel-context` - 内核上下文管理库（`ForeignContext`）
- `kernel-alloc` - 内核堆分配器
- `linker` - 链接脚本和应用程序管理
- `syscall` - 系统调用处理
- `xmas-elf` - ELF 文件解析

## 运行方法

```bash
$ cd ch4
$ cargo run

# 设置日志级别
$ LOG=INFO cargo run
```

## 关键概念

- **虚拟地址空间**：每个进程拥有独立的虚拟地址空间
- **页表**：用于虚拟地址到物理地址的转换
- **SV39 分页模式**：RISC-V 64 位架构的 39 位虚拟地址分页模式
- **地址空间隔离**：内核和应用程序的地址空间完全隔离
- **跨地址空间访问**：内核需要手动查页表来访问应用程序的数据
- **ForeignContext**：用于跨地址空间的上下文切换
- **传送门机制**：用于在地址空间切换时执行代码的特殊机制

## 与第三章的对比

| 特性 | 第三章 | 第四章 |
|------|--------|--------|
| 地址空间 | 所有任务共享物理地址空间 | 每个进程拥有独立的虚拟地址空间 |
| 内存保护 | 无 | 通过页表实现内存保护 |
| 地址转换 | 直接使用物理地址 | 通过 MMU 进行地址转换 |
| 隔离性 | 弱 | 强，完全隔离 |
| 安全性 | 低 | 高，可以应对 Meltdown 漏洞 |
| 实现复杂度 | 简单 | 复杂 |

## 注意事项

- 实验指导书存在的目的是帮助读者理解框架代码
- 为便于测试，完成编程实验时，请以框架代码为基础，不必跟着文档从零开始编写内核
- 本章涉及的内容比较复杂，需要理解虚拟内存、页表、地址空间等概念
- 地址空间切换有一定的性能开销，但提供了更好的安全性和隔离性
