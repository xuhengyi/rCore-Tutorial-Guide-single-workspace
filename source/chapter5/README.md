# 第五章：进程及进程管理

## 目录

1. [引言](0intro.md) - 本章导读和实践体验
2. [与进程有关的重要系统调用](1process.md) - fork/exec/waitpid 系统调用
3. [进程管理的核心数据结构](2core-data-structures.md) - 进程控制块和管理器
4. [进程管理机制的设计实现](3implement-process-mechanism.md) - 进程创建、调度和资源回收
5. [练习](4exercise.md) - 编程作业和问答作业

## 本章目标

本章的目标是实现进程管理系统，支持进程的创建、执行、等待和资源回收，并开发一个用户终端（Shell）程序。

## 主要内容

1. **进程概念**：从任务升级到进程，支持创建子进程和加载新程序
2. **进程系统调用**：实现 `fork`、`exec`、`wait`/`waitpid`、`getpid` 等系统调用
3. **进程管理**：使用 `rcore-task-manage` 库管理进程和父子关系
4. **进程调度**：实现进程的调度和切换机制
5. **Shell 程序**：实现用户终端，提供命令行交互界面

## 代码位置

本章的代码位于 `rCore-Tutorial-in-single-workspace/ch5/` 目录下。

主要文件：
- `src/main.rs` - 内核主函数，包含进程调度循环
- `src/process.rs` - 进程管理，包含 `fork` 和 `exec` 的实现
- `src/processor.rs` - 处理器管理，封装进程管理器

主要依赖库：
- `rcore-task-manage` - 任务管理库（`PManager`、`ProcManager`）
- `kernel-vm` - 虚拟内存管理库
- `kernel-context` - 内核上下文管理库（`ForeignContext`）
- `kernel-alloc` - 内核堆分配器
- `linker` - 链接脚本和应用程序管理库（支持按名称查找）
- `syscall` - 系统调用处理（新增进程相关系统调用）
- `xmas-elf` - ELF 文件解析

## 运行方法

```bash
$ cd ch5
$ cargo run

# 设置日志级别
$ LOG=INFO cargo run
```

运行后会进入 Shell 界面，可以输入应用名来执行应用。

## 关键概念

- **进程**：拥有独立地址空间和资源的执行实体
- **进程 ID (PID)**：唯一标识一个进程的整数
- **父子进程关系**：进程之间的层次关系
- **fork**：创建子进程的系统调用
- **exec**：加载新程序替换当前进程的系统调用
- **wait/waitpid**：等待子进程结束并回收资源的系统调用
- **Shell**：用户与操作系统交互的命令行界面
- **initproc**：系统初始进程，负责启动 Shell 和回收僵尸进程

## 与第四章的对比

| 特性 | 第四章 | 第五章 |
|------|--------|--------|
| 任务抽象 | 简单的任务 | 完整的进程（支持 fork/exec） |
| 进程创建 | 只能从 ELF 文件创建 | 可以从 ELF 创建，也可以通过 fork 创建 |
| 程序加载 | 启动时加载所有程序 | 运行时动态加载程序（exec） |
| 进程关系 | 无 | 支持父子进程关系 |
| 资源回收 | 进程退出即回收 | 支持 wait 等待子进程并回收 |
| 用户交互 | 无 | 支持 Shell 命令行界面 |

## 注意事项

- 实验指导书存在的目的是帮助读者理解框架代码
- 为便于测试，完成编程实验时，请以框架代码为基础，不必跟着文档从零开始编写内核
- 本章实现了基本的进程管理功能，但某些功能（如 `exit_code` 的处理）可能还有待完善
- `wait` 系统调用的语义可能与标准实现有所不同，因为子进程退出后会直接删除
