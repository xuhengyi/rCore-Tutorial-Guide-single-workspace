# 第二章：批处理系统

## 目录

1. [引言](0intro.md) - 本章导读和实践体验
2. [实现应用程序](2application.md) - 用户程序的设计和系统调用
3. [实现批处理操作系统](3batch-system.md) - 批处理系统的实现
4. [实现特权级的切换](4trap-handling.md) - Trap 处理和特权级切换
5. [练习](5exercise.md) - 编程作业和问答作业（已废弃，仅供参考）

## 本章目标

本章的目标是让我们的 OS 内核能以批处理的形式一次运行多个应用程序，同时利用特权级机制，令 OS 不因出错的用户态程序而崩溃。

## 主要内容

1. **应用程序设计**：了解用户程序的结构、内存布局和系统调用接口
2. **批处理系统**：实现能够依次加载和运行多个应用程序的批处理系统
3. **特权级切换**：理解和使用 RISC-V 的特权级机制
4. **Trap 处理**：实现系统调用和异常的处理机制

## 代码位置

本章的代码位于 `rCore-Tutorial-in-single-workspace/ch2/` 目录下。

主要文件：
- `src/main.rs` - 内核主函数，包含批处理逻辑和 Trap 处理

主要依赖库：
- `linker` - 链接脚本和应用程序管理
- `kernel-context` - 内核上下文管理（`LocalContext`）
- `syscall` - 系统调用处理
- `console` - 控制台输出
- `sbi` - SBI 调用封装

## 运行方法

```bash
$ cd ch2
$ cargo run
```

或者设置日志级别：

```bash
$ LOG=INFO cargo run
```

## 关键概念

- **批处理系统**：能够依次加载和运行多个应用程序的系统
- **特权级**：RISC-V 定义了多个特权级（M/S/U），用于隔离和保护
- **Trap**：从用户态切换到内核态的过程
- **系统调用**：用户程序请求内核服务的接口
- **LocalContext**：管理用户程序执行上下文的数据结构
- **上下文切换**：保存和恢复寄存器状态，实现不同特权级之间的切换

## 本章特点

本章实现的操作系统被称为"邓氏鱼"（Dunkleosteus）。邓氏鱼是这样一种生物：在它生存的年代，它最大、最强，非常有效的颌、眼睛和尾巴提供了充分强大的咬合力、视力和游泳能力，这些结构在泥盆纪都堪称先进。然而，在泥盆纪末灭绝事件中，以邓氏鱼为代表的所有盾皮鱼类都迅速而彻底地灭绝了。在今天的海洋里，我们没有发现什么与之在演化上接近的生物。演化就是这样短视。一时非常有效的设计，可能随着环境微妙的一点改变就完全不适用了，设计也是一样。

因此，在迈向更复杂的系统之前，就让我们任性地实现一个保持简单的单道批处理系统吧。如你所见，第二章依然只有一个 `main.rs` 文件，而且算上注释也不到 150 行（当然，它使用了更多的依赖）。重点关注 `syscall` 和 `LocalContext` 的用法，这就是邓氏鱼的大脑和脊椎，这些真正成功的结构是不会随着某些物种的灭绝而消失的。

## 注意事项

- 实验指导书存在的目的是帮助读者理解框架代码
- 为便于测试，完成编程实验时，请以框架代码为基础，不必跟着文档从零开始编写内核
- 如果修改了用户程序，需要 `cargo clean` 重新编译才能刷新
- 本章重点关注系统调用和上下文切换的实现，这些是后续章节的基础
