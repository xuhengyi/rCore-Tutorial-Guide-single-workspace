# 分时多任务系统

## 概述

现代的任务调度算法基本都是抢占式的，它要求每个应用只能连续执行一段时间，然后内核就会将它强制性切换出去。一般将 **时间片** (Time Slice) 作为应用连续执行时长的度量单位，每个时间片可能在毫秒量级。简单起见，我们使用 **时间片轮转算法** (RR, Round-Robin) 来对应用进行调度。

## 时钟中断与计时器

实现调度算法需要计时。RISC-V 要求处理器维护时钟计数器 `mtime`，还有另外一个 CSR `mtimecmp`。一旦计数器 `mtime` 的值超过了 `mtimecmp`，就会触发一次时钟中断。

运行在 M 特权级的 SBI 已经预留了相应的接口，基于此编写的 `get_time` 函数可以取得当前 `mtime` 计数器的值。

在本项目的代码框架中，我们使用 `sbi::set_timer()` 来设置时钟中断：

```rust
// ch3/src/main.rs

#[cfg(not(feature = "coop"))]
sbi::set_timer(time::read64() + 12500);
```

这行代码会在当前时间的基础上增加 12500 个时钟周期后触发时钟中断。这个值对应大约 10ms 的时间片（假设时钟频率为 125MHz）。

## 时钟中断处理

在 `ch3/src/main.rs` 中，时钟中断的处理如下：

```rust
Trap::Interrupt(Interrupt::SupervisorTimer) => {
    sbi::set_timer(u64::MAX);
    log::trace!("app{i} timeout");
    false
}
```

当发生时钟中断时：
1. 将计时器设置为 `u64::MAX`，禁用时钟中断
2. 记录日志
3. 返回 `false`，表示任务未完成，但需要切换

然后循环会退出，切换到下一个任务。

## 启用时钟中断

在执行第一个应用前，我们需要启用时钟中断：

```rust
// ch3/src/main.rs

extern "C" fn rust_main() -> ! {
    // ...
    // 打开中断
    unsafe { sie::set_stimer() };
    // 多道执行
    // ...
}
```

`sie::set_stimer()` 会设置 `sie` CSR 的 `stie` 位，使得 S 特权级时钟中断不会被屏蔽。

## 抢占式调度流程

完整的抢占式调度流程如下：

1. **初始化**：
   - 启用时钟中断（`sie::set_stimer()`）
   - 加载所有应用程序到内存

2. **执行任务**：
   - 设置时钟中断（`sbi::set_timer(time::read64() + 12500)`）
   - 执行任务（`tcb.execute()`）

3. **处理 Trap**：
   - **时钟中断**：停止计时器，退出循环，切换到下一个任务
   - **系统调用**：处理系统调用，根据结果决定是否切换
   - **异常**：标记任务完成，切换到下一个任务

4. **任务切换**：
   - 通过轮询方式切换到下一个任务（`i = (i + 1) % index_mod`）

## 时间片轮转算法

时间片轮转算法的特点：

- **公平性**：每个任务获得相同的时间片
- **响应性**：任务可以在合理的时间内得到执行
- **简单性**：实现简单，开销小

在本章的实现中，我们使用简单的轮询方式来实现时间片轮转：

```rust
i = (i + 1) % index_mod;
```

这行代码会循环遍历所有任务，实现轮询调度。

## 协作式 vs 抢占式

| 特性 | 协作式调度 | 抢占式调度 |
|------|-----------|-----------|
| 切换时机 | 任务主动调用 `sys_yield` | 时钟中断触发 |
| 公平性 | 依赖任务主动让出 CPU | 强制切换，更公平 |
| 响应性 | 如果任务不主动让出，响应性差 | 响应性好 |
| 实现复杂度 | 简单 | 需要处理时钟中断 |
| 适用场景 | 任务都是协作的 | 通用场景 |

在本章中，可以通过 `coop` feature 来选择使用协作式或抢占式调度：

```bash
# 协作式调度（不使用时钟中断）
$ cargo run --features coop

# 抢占式调度（使用时钟中断，默认）
$ cargo run
```

## 时钟相关系统调用

本章还新增了时钟相关的系统调用，让应用程序可以获取当前时间：

```rust
// ch3/src/main.rs (impls 模块)

impl Clock for SyscallContext {
    #[inline]
    fn clock_gettime(&self, _caller: syscall::Caller, clock_id: ClockId, tp: usize) -> isize {
        match clock_id {
            ClockId::CLOCK_MONOTONIC => {
                let time = riscv::register::time::read() * 10000 / 125;
                *unsafe { &mut *(tp as *mut TimeSpec) } = TimeSpec {
                    tv_sec: time / 1_000_000_000,
                    tv_nsec: time % 1_000_000_000,
                };
                0
            }
            _ => -1,
        }
    }
}
```

这个系统调用可以让应用程序获取当前的单调时钟时间。

## RISC-V 架构中的嵌套中断问题

默认情况下，当 Trap 进入某个特权级之后，在 Trap 处理的过程中同特权级的中断都会被屏蔽。

- 当 Trap 发生时，`sstatus.sie` 会被保存在 `sstatus.spie` 字段中，同时 `sstatus.sie` 置零，这也就在 Trap 处理的过程中屏蔽了所有 S 特权级的中断；
- 当 Trap 处理完毕 `sret` 的时候，`sstatus.sie` 会恢复到 `sstatus.spie` 内的值。

也就是说，如果不去手动设置 `sstatus` CSR，在只考虑 S 特权级中断的情况下，是不会出现 **嵌套中断** (Nested Interrupt) 的。

> **注意**：**嵌套中断与嵌套 Trap**
> 
> 嵌套中断可以分为两部分：在处理一个中断的过程中又被同特权级/高特权级中断所打断。默认情况下硬件会避免前一部分，也可以通过手动设置来允许前一部分的存在；而从上面介绍的规则可以知道，后一部分则是无论如何设置都不可避免的。
> 
> 嵌套 Trap 则是指处理一个 Trap 过程中又再次发生 Trap，嵌套中断算是嵌套 Trap 的一种。

## 关键概念总结

1. **时间片**：每个任务连续执行的时间长度
2. **时间片轮转**：每个任务获得相同的时间片，轮流执行
3. **时钟中断**：用于实现时间片的计时机制
4. **抢占式调度**：内核通过时钟中断强制切换任务
5. **协作式调度**：任务主动让出 CPU（通过 `sys_yield`）

通过这些机制，我们实现了真正的分时多任务系统，可以公平地为多个任务分配 CPU 时间。
