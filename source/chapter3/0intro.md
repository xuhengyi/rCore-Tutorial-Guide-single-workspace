# 引言

## 本章导读

本章的目标是实现分时多任务系统，它能并发地执行多个用户程序，并调度这些程序。为此需要实现：

- 一次性加载所有用户程序，减少任务切换开销；
- 支持任务切换机制，保存切换前后程序上下文；
- 支持程序主动放弃处理器，实现 yield 系统调用；
- 以时间片轮转算法调度用户程序，实现资源的时分复用。

## 实践体验

在 qemu 模拟器上运行本章代码：

```bash
$ cd ch3
$ cargo run
```

或者启用协作式调度（不使用时钟中断）：

```bash
$ cargo run --features coop
```

运行代码，看到用户程序交替输出信息，多个程序并发执行。

## 本章代码树

```
rCore-Tutorial-in-single-workspace/
├── ch3/
│   ├── Cargo.toml          # 项目配置文件（包含 coop feature）
│   ├── build.rs            # 构建脚本
│   ├── README.md           # 本章说明文档
│   └── src/
│       ├── main.rs         # 内核主函数，包含多道程序和调度逻辑
│       └── task.rs         # 任务控制块实现
├── linker/                 # 链接脚本和应用程序管理库
├── kernel-context/         # 内核上下文管理库
├── syscall/                # 系统调用库（新增调度相关系统调用）
├── console/                # 控制台库
└── sbi/                    # SBI 调用封装（新增 set_timer）
```

本章代码相比第二章的主要变化：

- **多道程序加载**：所有应用程序在启动时一次性加载到内存的不同位置
- **任务控制块**：使用 `TaskControlBlock` 管理每个任务的执行状态
- **任务切换**：通过 `LocalContext` 实现任务之间的切换
- **协作式调度**：支持 `sys_yield` 系统调用，让程序主动让出 CPU
- **抢占式调度**：使用时钟中断实现时间片轮转调度（默认启用，可通过 `coop` feature 禁用）

## 关键概念

- **多道程序**：多个程序同时驻留在内存中，可以快速切换执行
- **任务切换**：从一个任务切换到另一个任务，需要保存和恢复上下文
- **协作式调度**：任务主动让出 CPU（通过 `sys_yield`）
- **抢占式调度**：内核通过时钟中断强制切换任务
- **时间片**：每个任务连续执行的时间长度
