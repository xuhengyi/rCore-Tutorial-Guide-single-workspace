# 第三章：多道程序与分时多任务

## 目录

1. [引言](0intro.md) - 本章导读和实践体验
2. [多道程序放置与加载](1multi-loader.md) - 一次性加载所有应用程序
3. [任务切换](2task-switching.md) - 任务切换机制
4. [管理多道程序](3multiprogramming.md) - 任务管理和协作式调度
5. [分时多任务系统](4time-sharing-system.md) - 抢占式调度和时间片轮转
6. [练习](5exercise.md) - 编程作业和问答作业

## 本章目标

本章的目标是实现分时多任务系统，它能并发地执行多个用户程序，并调度这些程序。

## 主要内容

1. **多道程序加载**：一次性加载所有应用程序到内存的不同位置
2. **任务切换**：实现任务之间的快速切换机制
3. **协作式调度**：支持 `sys_yield` 系统调用，让程序主动让出 CPU
4. **抢占式调度**：使用时钟中断实现时间片轮转调度

## 代码位置

本章的代码位于 `rCore-Tutorial-in-single-workspace/ch3/` 目录下。

主要文件：
- `src/main.rs` - 内核主函数，包含多道程序和调度逻辑
- `src/task.rs` - 任务控制块实现

主要依赖库：
- `linker` - 链接脚本和应用程序管理
- `kernel-context` - 内核上下文管理（`LocalContext`）
- `syscall` - 系统调用处理（新增调度、时钟相关系统调用）
- `console` - 控制台输出
- `sbi` - SBI 调用封装（新增 `set_timer`）

## 运行方法

```bash
# 抢占式调度（默认，使用时钟中断）
$ cd ch3
$ cargo run

# 协作式调度（不使用时钟中断）
$ cargo run --features coop

# 设置日志级别
$ LOG=INFO cargo run
```

## 关键概念

- **多道程序**：多个程序同时驻留在内存中，可以快速切换执行
- **任务控制块**：管理每个任务的执行状态和上下文
- **任务切换**：从一个任务切换到另一个任务，需要保存和恢复上下文
- **协作式调度**：任务主动让出 CPU（通过 `sys_yield`）
- **抢占式调度**：内核通过时钟中断强制切换任务
- **时间片**：每个任务连续执行的时间长度
- **时间片轮转**：每个任务获得相同的时间片，轮流执行

## 与第二章的对比

| 特性 | 第二章 | 第三章 |
|------|--------|--------|
| 应用程序加载 | 每次只加载一个，运行完再加载下一个 | 启动时一次性加载所有应用程序 |
| 内存使用 | 所有应用共享同一个起始地址 | 每个应用有独立的起始地址 |
| 切换开销 | 需要重新加载应用程序 | 只需切换上下文，开销更小 |
| 并发性 | 串行执行 | 可以快速切换，实现并发效果 |
| 调度方式 | 无调度，按顺序执行 | 支持协作式和抢占式调度 |

## 注意事项

- 实验指导书存在的目的是帮助读者理解框架代码
- 为便于测试，完成编程实验时，请以框架代码为基础，不必跟着文档从零开始编写内核
- 可以通过 `coop` feature 选择使用协作式或抢占式调度
- 本章重点关注任务管理和调度机制，这些是后续章节的基础
