# 内核态的线程管理

## 线程概念

这里会结合与进程的比较来说明线程的概念。到本章之前，我们看到了进程这一抽象，操作系统让进程拥有相互隔离的虚拟的地址空间，让进程感到在独占一个虚拟的处理器。其实这只是操作系统通过时分复用和空分复用技术来让每个进程复用有限的物理内存和物理CPU。而线程是在进程内中的一个新的抽象。在没有线程之前，一个进程在一个时刻只有一个执行点（即程序计数器 (PC) 寄存器保存的要执行指令的指针）。但线程的引入把进程内的这个单一执行点给扩展为多个执行点，即在进程中存在多个线程，每个线程都有一个执行点。而且这些线程共享进程的地址空间，所以可以不必采用相对比较复杂的 IPC 机制（一般需要内核的介入），而可以很方便地直接访问进程内的数据。

在线程的具体运行过程中，需要有程序计数器寄存器来记录当前的执行位置，需要有一组通用寄存器记录当前的指令的操作数据，需要有一个栈来保存线程执行过程的函数调用栈和局部变量等，这就形成了线程上下文的主体部分。这样如果两个线程运行在一个处理器上，就需要采用类似两个进程运行在一个处理器上的调度/切换管理机制，即需要在一定时刻进行线程切换，并进行线程上下文的保存与恢复。这样在一个进程中的多线程可以独立运行，取代了进程，成为操作系统调度的基本单位。

由于把进程的结构进行了细化，通过线程来表示对处理器的虚拟化，使得进程成为了管理线程的容器。在进程中的线程没有父子关系，大家都是兄弟，但还是有个老大。这个代表老大的线程其实就是创建进程（比如通过 `fork` 系统调用创建进程）时，建立的第一个线程，它的线程标识符（TID）为 `0`。

## 线程模型与重要系统调用

目前，我们只介绍本章实现的内核中采用的一种非常简单的线程模型。这个线程模型有三个运行状态：就绪态、运行态和等待态；共享所属进程的地址空间和其他共享资源（如文件等）；可被操作系统调度来分时占用CPU执行；可以动态创建和退出；可通过系统调用获得操作系统的服务。我们实现的线程模型建立在进程的地址空间抽象之上：每个线程都共享进程的代码段和可共享的地址空间（如全局数据段、堆等），但有自己的独占的栈。

线程模型需要操作系统支持一些重要的系统调用：创建线程、等待子线程结束等，来支持灵活的多线程应用。接下来会介绍这些系统调用的基本功能和设计思路。

### 线程创建系统调用

在一个进程的运行过程中，进程可以创建多个属于这个进程的线程，每个线程有自己的线程标识符（TID，Thread Identifier）。系统调用 `thread_create` 的原型如下：

```rust
/// 功能：当前进程创建一个新的线程
/// 参数：entry 表示线程的入口函数地址
/// 参数：arg：表示线程的一个参数
pub fn sys_thread_create(entry: usize, arg: usize) -> isize
```

当进程调用 `thread_create` 系统调用后，内核会在这个进程内部创建一个新的线程，这个线程能够访问到进程所拥有的代码段、堆和其他数据段。但内核会给这个新线程分配一个它专有的用户态栈，这样每个线程才能相对独立地被调度和执行。另外，由于用户态进程与内核之间有各自独立的页表，所以二者需要有一个跳板页 `TRAMPOLINE` 来处理用户态切换到内核态的地址空间平滑转换的事务。所以当出现线程后，在进程中的每个线程也需要有一个独立的跳板页 `TRAMPOLINE` 来完成同样的事务。

相比于创建进程的 `fork` 系统调用，创建线程不需要要建立新的地址空间，这是二者之间最大的不同。另外属于同一进程中的线程之间没有父子关系，这一点也与进程不一样。

### 等待子线程系统调用

当一个线程执行完代表它的功能后，会通过 `exit` 系统调用退出。内核在收到线程发出的 `exit` 系统调用后，会回收线程占用的部分资源，即用户态用到的资源，比如用户态的栈，用于系统调用和异常处理的跳板页等。而该线程的内核态用到的资源，比如内核栈等，需要通过进程/主线程调用 `waittid` 来回收了，这样整个线程才能被彻底销毁。系统调用 `waittid` 的原型如下：

```rust
/// 参数：tid表示线程id
/// 返回值：如果线程不存在，返回-1；如果线程还没退出，返回-2；其他情况下，返回结束线程的退出码
pub fn sys_waittid(tid: usize) -> i32
```

一般情况下进程/主线程要负责通过 `waittid` 来等待它创建出来的线程（不是主线程）结束并回收它们在内核中的资源（如线程的内核栈、线程控制块等）。如果进程/主线程先调用了 `exit` 系统调用来退出，那么整个进程（包括所属的所有线程）都会退出，而对应父进程会通过 `waitpid` 回收子进程剩余还没被回收的资源。

### 进程相关的系统调用

在引入了线程机制后，进程相关的重要系统调用：`fork`、`exec`、`waitpid` 虽然在接口上没有变化，但在它要完成的功能上需要有一定的扩展。首先，需要注意到把以前进程中与处理器执行相关的部分拆分到线程中。这样，在通过 `fork` 创建进程其实也意味着要单独建立一个主线程来使用处理器，并为以后创建新的线程建立相应的线程控制块向量。相对而言，`exec` 和 `waitpid` 这两个系统调用要做的改动比较小，还是按照与之前进程的处理方式来进行。总体上看，进程相关的这三个系统调用还是保持了已有的进程操作的语义，并没有由于引入了线程，而带来大的变化。

## 应用程序示例

我们刚刚介绍了 thread_create/waittid 两个重要系统调用，我们可以借助它们和之前实现的系统调用，开发出功能更为灵活的应用程序。下面我们通过描述一个多线程应用程序 `threads` 的开发过程来展示这些系统调用的使用方法。

### 系统调用封装

同学可以在 user/src/syscall.rs 中看到以 sys_* 开头的系统调用的函数原型，它们后续还会在 user/src/lib.rs 中被封装成方便应用程序使用的形式。如 `sys_thread_create` 被封装成 `thread_create`，而 `sys_waittid` 被封装成 `waittid`：

```rust
pub fn thread_create(entry: usize, arg: usize) -> isize { sys_thread_create(entry, arg) }

pub fn waittid(tid: usize) -> isize {
    loop {
        match sys_waittid(tid) {
            -2 => { yield_(); }
            exit_code => return exit_code,
        }
    }
}
```

`waittid` 等待一个线程标识符的值为 tid 的线程结束。在具体实现方面，我们看到当 `sys_waittid` 返回值为 -2，即要等待的线程存在但它却尚未退出的时候，主线程调用 `yield_` 主动交出 CPU 使用权，待下次 CPU 使用权被内核交还给它的时候再次调用 `sys_waittid` 查看要等待的线程是否退出。这样做是为了减小 CPU 资源的浪费。这种方法是为了尽可能简化内核的实现。

### 多线程应用程序 -- threads

多线程应用程序 -- threads 开始执行后，先调用 `thread_create` 创建了三个线程，加上进程自带的主线程，其实一共有四个线程。每个线程在打印了1000个字符后，会执行 `exit` 退出。进程通过 `waittid` 等待这三个线程结束后，最终结束进程的执行。下面是多线程应用程序 -- threads 的源代码：

```rust
//usr/src/bin/ch8b_threads.rs

use user_lib::{thread_create, waittid, exit};

pub fn thread_a() -> ! {
    for _ in 0..1000 { print!("a"); }
    exit(1)
}

pub fn thread_b() -> ! {
    for _ in 0..1000 { print!("b"); }
    exit(2)
}

pub fn thread_c() -> ! {
    for _ in 0..1000 { print!("c"); }
    exit(3)
}

#[no_mangle]
pub fn main() -> i32 {
    let mut v = Vec::new();
    v.push(thread_create(thread_a as usize, 0));
    v.push(thread_create(thread_b as usize, 0));
    v.push(thread_create(thread_c as usize, 0));
    for tid in v.iter() {
        let exit_code = waittid(*tid as usize);
        println!("thread#{} exited with code {}", tid, exit_code);
    }
    println!("main thread exited.");
    0
}
```

## 线程管理的核心数据结构

为了在现有进程管理的基础上实现线程管理，我们需要改进一些数据结构包含的内容及接口。基本思路就是把进程中与处理器相关的部分分拆出来，形成线程相关的部分。

本节将按照如下顺序来进行介绍：

- **Thread**：表示线程的核心数据结构。
- **Process**：进程控制块，管理线程集合和共享资源。
- **Processor**：用于线程调度，维护线程的处理器状态。

### 线程控制块

在内核中，每个线程的执行状态和线程上下文等均保存在一个被称为线程控制块（Thread）的结构中，它是内核对线程进行管理的核心数据结构。在内核看来，它就等价于一个线程。

在 ch8 的实现中，`Thread` 结构如下：

```rust
pub struct Thread {
    /// 不可变
    pub tid: ThreadId,
    /// 可变
    pub context: ForeignContext,
}
```

线程控制块主要包括在线程初始化之后就不再变化的元数据：线程标识符（TID）和线程上下文（`ForeignContext`）。线程上下文包含线程的寄存器状态和地址空间信息，用于线程切换。

### 包含线程的进程控制块

把线程相关数据单独组织成数据结构后，进程的结构也需要进行一定的调整：

```rust
pub struct Process {
    /// 不可变
    pub pid: ProcId,
    /// 可变
    pub address_space: AddressSpace<Sv39, Sv39Manager>,
    /// 文件描述符表
    pub fd_table: Vec<Option<Mutex<FileHandle>>>,
    /// 信号模块
    pub signal: Box<dyn Signal>,
    /// 分配的锁以及信号量
    pub semaphore_list: Vec<Option<Arc<Semaphore>>>,
    pub mutex_list: Vec<Option<Arc<dyn MutexTrait>>>,
    pub condvar_list: Vec<Option<Arc<Condvar>>>,
}
```

从中可以看出，进程把与处理器执行相关的部分都移到了 `Thread` 中，并组织为一个线程控制块向量中，这就自然对应到多个线程的管理上了。进程还管理了线程共享的资源，如地址空间、文件描述符表、信号模块，以及同步互斥资源（信号量、互斥锁、条件变量）。

## 线程管理机制的设计与实现

在上述线程模型和内核数据结构的基础上，我们还需完成线程管理的基本实现，从而构造出一个完整的操作系统。本节将分析如何实现线程管理：

- 线程创建、线程退出与等待线程结束
- 线程执行中的特权级切换

### 线程创建、线程退出与等待线程结束

#### 线程创建

当一个进程执行中发出了创建线程的系统调用 `sys_thread_create` 后，操作系统就需要在当前进程的基础上创建一个线程了，这里重点是需要了解创建线程控制块，在线程控制块中初始化各个成员变量，建立好进程和线程的关系等。只有建立好这些成员变量，才能给线程建立一个灵活方便的执行环境。这里列出支持线程正确运行所需的重要的执行环境要素：

- 线程的用户态栈：确保在用户态的线程能正常执行函数调用；
- 线程的内核态栈：确保线程陷入内核后能正常执行函数调用；
- 线程的跳板页：确保线程能正确的进行用户态<-->内核态切换；
- 线程上下文：即线程用到的寄存器信息，用于线程切换。

线程创建的具体实现需要：

1. 找到当前正在执行的线程和此线程所属的进程。
2. 调用 `Thread::new` 方法，创建一个新的线程，在创建过程中，建立与进程的所属关系，分配了线程用户态栈、内核态栈、用于异常/中断的跳板页。
3. 把线程挂到调度队列中。
4. 把线程接入到所需进程的线程列表中。
5. 初始化位于该线程在用户态地址空间中的 Trap 上下文：设置线程的函数入口点和用户栈，使得第一次进入用户态时能从线程起始位置开始正确执行；设置好内核栈和陷入函数指针 `trap_handler`，保证在 Trap 的时候用户态的线程能正确进入内核态。

#### 线程退出

当一个非主线程的其他线程发出 `sys_exit` 系统调用时，内核会调用相关函数退出当前线程并切换到下一个线程，但不会导致其所属进程的退出。当**主线程**即进程发出这个系统调用，内核会回收整个进程（这包括了其管理的所有线程）资源，并退出。主线程本身不会被立即回收资源，而是延迟回收。

#### 等待线程结束

主线程通过系统调用 `sys_waittid` 来等待其他线程的结束。具体实现需要：

1. 如果是线程等自己，返回错误。
2. 如果找到 `tid` 对应的退出线程，则收集该退出线程的退出码，否则返回错误（退出线程不存在）。
3. 如果退出码存在，则清空进程中对应此退出线程的线程控制块（至此，线程所占资源算是全部清空了），否则返回错误（线程还没退出）。

### 线程执行中的特权级切换和调度切换

线程执行中的特权级切换与第三章中**任务切换的设计与实现**小节中讲解的过程是一致的。而线程执行中的调度切换过程与第五章的**进程调度机制**小节中讲解的过程是一致的。这里就不用再赘述一遍了。

## 小结

- **线程**：进程内的执行实体，共享进程的地址空间和文件，但有自己的栈和上下文
- **线程创建**：通过 `thread_create` 系统调用，为新线程分配栈和上下文
- **线程退出**：通过 `exit` 系统调用，主线程退出会导致整个进程退出
- **等待线程**：通过 `waittid` 系统调用，主线程等待其他线程结束并回收资源
- **线程调度**：线程成为操作系统调度的基本单位，取代了进程
